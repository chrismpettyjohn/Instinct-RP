{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/chris/Projects/instinct/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"/Users/chris/Projects/instinct/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import WebSocketRetry from'reconnecting-websocket';export var WebSocketService=function WebSocketService(ip,port,sso){var _this=this;_classCallCheck(this,WebSocketService);this.sso=sso;this.connection=void 0;this.subscribers={};this.onConnectionStarted=function(){_this.sendEvent('auth_with_sso',{sso_ticket:_this.sso});};this.onConnectionClosed=function(event){console.log('WS: Connection Closed ',event);};this.onMessage=function(event){var _this$subscribers$eve;var _JSON$parse=JSON.parse(event.data),event_name=_JSON$parse.event_name,event_data=_JSON$parse.event_data;var subscribers=(_this$subscribers$eve=_this.subscribers[event_name])!==null&&_this$subscribers$eve!==void 0?_this$subscribers$eve:[];console.log(event_name,event_data);var _iterator=_createForOfIteratorHelper(subscribers),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var subscriber=_step.value;subscriber(event_data);}}catch(err){_iterator.e(err);}finally{_iterator.f();}};this.addSubscriber=function(event,callback){if(_this.subscribers[event]){_this.subscribers[event].push(callback);}else{_this.subscribers[event]=[callback];}};this.sendEvent=function(event,payload){_this.connection.send(JSON.stringify({event_name:event,event_data:payload}));};this.getConnectionStatus=function(){return _this.connection.readyState===_this.connection.OPEN;};this.retry=function(){_this.connection.reconnect();};this.connection=new WebSocketRetry(\"\".concat(ip,\":\").concat(port));this.connection.onopen=this.onConnectionStarted;this.connection.onmessage=this.onMessage;};","map":{"version":3,"sources":["/Users/chris/Projects/instinct/packages/@instinct-theme/roleplay/src/services/web-socket/WebSocket.ts"],"names":["WebSocketRetry","WebSocketService","ip","port","sso","connection","subscribers","onConnectionStarted","sendEvent","sso_ticket","onConnectionClosed","event","console","log","onMessage","JSON","parse","data","event_name","event_data","subscriber","addSubscriber","callback","push","payload","send","stringify","getConnectionStatus","readyState","OPEN","retry","reconnect","onopen","onmessage"],"mappings":"oUAAA,MAAOA,CAAAA,cAAP,KAA2B,wBAA3B,CASA,UAAaC,CAAAA,gBAAb,CAKE,0BAAYC,EAAZ,CAAwBC,IAAxB,CAA+CC,GAA/C,CAA4D,4DAAbA,GAAa,CAAbA,GAAa,MAJnDC,UAImD,aAF5DC,WAE4D,CAFF,EAEE,MAM5DC,mBAN4D,CAMtC,UAAM,CAC1B,KAAI,CAACC,SAAL,CAAe,eAAf,CAAgC,CAC9BC,UAAU,CAAE,KAAI,CAACL,GADa,CAAhC,EAGD,CAV2D,MAY5DM,kBAZ4D,CAYvC,SAACC,KAAD,CAAuB,CAC1CC,OAAO,CAACC,GAAR,CAAY,wBAAZ,CAAsCF,KAAtC,EACD,CAd2D,MAgB5DG,SAhB4D,CAgBhD,SAACH,KAAD,CAAyB,2BACnC,gBAAiCI,IAAI,CAACC,KAAL,CAAWL,KAAK,CAACM,IAAjB,CAAjC,CAAOC,UAAP,aAAOA,UAAP,CAAmBC,UAAnB,aAAmBA,UAAnB,CACA,GAAMb,CAAAA,WAAW,wBAAG,KAAI,CAACA,WAAL,CAAiBY,UAAjB,CAAH,+DAAmC,EAApD,CAEAN,OAAO,CAACC,GAAR,CAAYK,UAAZ,CAAwBC,UAAxB,EAJmC,yCAMVb,WANU,YAMnC,+CAAsC,IAA3Bc,CAAAA,UAA2B,aACpCA,UAAU,CAACD,UAAD,CAAV,CACD,CARkC,qDASpC,CAzB2D,MA2B5DE,aA3B4D,CA2B5C,SACdV,KADc,CAEdW,QAFc,CAGX,CACH,GAAI,KAAI,CAAChB,WAAL,CAAiBK,KAAjB,CAAJ,CAA6B,CAC3B,KAAI,CAACL,WAAL,CAAiBK,KAAjB,EAAwBY,IAAxB,CAA6BD,QAA7B,EACD,CAFD,IAEO,CACL,KAAI,CAAChB,WAAL,CAAiBK,KAAjB,EAA0B,CAACW,QAAD,CAA1B,CACD,CACF,CApC2D,MAsC5Dd,SAtC4D,CAsChD,SACVG,KADU,CAEVa,OAFU,CAGP,CACH,KAAI,CAACnB,UAAL,CAAgBoB,IAAhB,CACEV,IAAI,CAACW,SAAL,CAAe,CACbR,UAAU,CAAEP,KADC,CAEbQ,UAAU,CAAEK,OAFC,CAAf,CADF,EAMD,CAhD2D,MAkD5DG,mBAlD4D,CAkDtC,UAAe,CACnC,MAAO,CAAA,KAAI,CAACtB,UAAL,CAAgBuB,UAAhB,GAA+B,KAAI,CAACvB,UAAL,CAAgBwB,IAAtD,CACD,CApD2D,MAsD5DC,KAtD4D,CAsDpD,UAAM,CACZ,KAAI,CAACzB,UAAL,CAAgB0B,SAAhB,GACD,CAxD2D,CAC1D,KAAK1B,UAAL,CAAkB,GAAIL,CAAAA,cAAJ,WAAsBE,EAAtB,aAA4BC,IAA5B,EAAlB,CACA,KAAKE,UAAL,CAAgB2B,MAAhB,CAAyB,KAAKzB,mBAA9B,CACA,KAAKF,UAAL,CAAgB4B,SAAhB,CAA4B,KAAKnB,SAAjC,CACD,CATH","sourcesContent":["import WebSocketRetry from 'reconnecting-websocket';\nimport {WebSocketServiceBase, WebSocketSubscriber} from './WebSocket.types';\nimport {\n  WebSocketIncomingEvent,\n  WebSocketIncomingEvents,\n  WebSocketOutgoingEvent,\n  WebSocketOutgoingEvents,\n} from '@instinct-plugin/roleplay-types';\n\nexport class WebSocketService implements WebSocketServiceBase {\n  readonly connection: WebSocketRetry;\n\n  subscribers: Record<string, WebSocketSubscriber<any>[]> = {};\n\n  constructor(ip: string, port: string, readonly sso: string) {\n    this.connection = new WebSocketRetry(`${ip}:${port}`);\n    this.connection.onopen = this.onConnectionStarted;\n    this.connection.onmessage = this.onMessage;\n  }\n\n  onConnectionStarted = () => {\n    this.sendEvent('auth_with_sso', {\n      sso_ticket: this.sso,\n    });\n  };\n\n  onConnectionClosed = (event: CloseEvent) => {\n    console.log('WS: Connection Closed ', event);\n  };\n\n  onMessage = (event: MessageEvent) => {\n    const {event_name, event_data} = JSON.parse(event.data);\n    const subscribers = this.subscribers[event_name] ?? [];\n\n    console.log(event_name, event_data);\n\n    for (const subscriber of subscribers) {\n      subscriber(event_data);\n    }\n  };\n\n  addSubscriber = <K extends WebSocketIncomingEvent>(\n    event: K,\n    callback: WebSocketSubscriber<WebSocketIncomingEvents[K]>\n  ) => {\n    if (this.subscribers[event]) {\n      this.subscribers[event].push(callback);\n    } else {\n      this.subscribers[event] = [callback];\n    }\n  };\n\n  sendEvent = <K extends WebSocketOutgoingEvent>(\n    event: K,\n    payload: WebSocketOutgoingEvents[K]\n  ) => {\n    this.connection.send(\n      JSON.stringify({\n        event_name: event,\n        event_data: payload,\n      })\n    );\n  };\n\n  getConnectionStatus = (): boolean => {\n    return this.connection.readyState === this.connection.OPEN;\n  };\n\n  retry = () => {\n    this.connection.reconnect();\n  };\n}\n"]},"metadata":{},"sourceType":"module"}